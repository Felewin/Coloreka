<html><head>
<title>Coloreka!</title>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400..800&display=swap" rel="stylesheet">
<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
  
  body {
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    display: flex;
  }
  
  * {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
  }

  #leftColor, #rightColor {
    flex: 1;
    height: 100%;
    position: relative;
    overflow: hidden;
  }

  #rightColor {
    display: none;
  }

  .ripple {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: scale(0);
    opacity: 0;
    animation: rippleExpand 800ms ease-out forwards;
    z-index: 1100;
    mix-blend-mode: screen;
    will-change: transform, opacity;
  }

  @media (hover: none) and (pointer: coarse) {
    .ripple {
      mix-blend-mode: normal;
    }
  }

  .colorLayer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transition: opacity 0.5s ease;
  }

  .wipe-transition {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transition: transform 0.5s ease, opacity 0.5s ease;
    backface-visibility: hidden;
  }

  @keyframes zoomIn {
    from { transform: scale(0); }
    to { transform: scale(1); }
  }

  @keyframes rotateIn {
    from { transform: rotate(-180deg) scale(0); }
    to { transform: rotate(0) scale(1); }
  }

  #introScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, 
      #FFB3BA, #FFDFBA, #FFFFBA, #BAFFC9, #BAE1FF, #E0BBE4, #FFB3BA
    );
    background-size: 200% 100%;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    animation: moveGradient 10s linear infinite;
  }

  .baloo-2-intro-title {
    font-family: "Baloo 2", sans-serif;
    font-optical-sizing: auto;
    font-weight: 800;
    font-style: normal;
    font-size: 8vw;
    background: linear-gradient(
      to right,
      #FFB3BA, #E0BBE4, #BAE1FF, #BAFFC9, #FFFFBA, #FFDFBA, #FFB3BA
    );
    background-size: 200% auto;
    color: transparent;
    -webkit-background-clip: text;
    background-clip: text;
    opacity: 0;
    animation: rainbow 10s linear infinite;
    margin-bottom: 2vh;
  }

  .title-fade-in {
    animation: fadeIn 2s ease-in-out forwards, rainbow 10s linear infinite;
  }

  #introRules {
    font-family: "Baloo 2", sans-serif;
    font-size: 2vw;
    color: #333;
    text-align: left;
    background-color: rgba(255, 255, 255, 0.5);
    padding: 2vh;
    border-radius: 10px;
    max-width: 80%;
    overflow-y: auto;
    max-height: 60vh;
    animation: fadeIn 2s ease-in-out;
    position: relative;
  }

  #introRules h3 {
    margin-top: 0;
  }

  #introRules ul {
    list-style-type: none;
    padding-left: 0;
  }

  #introRules li {
    margin-bottom: 1vh;
  }

  .also-plays-text {
    position: absolute;
    top: 2vh;
    right: 2vh;
    font-size: 1.2vw;
    color: #333;
    font-weight: 600;
    opacity: 0.8;
  }

  @media (orientation: portrait) {
    .baloo-2-intro-title {
      font-size: 16vw;
    }
    #introRules {
      font-size: 4vw;
    }
    .also-plays-text {
      font-size: 4.8vw;
      top: auto;
      bottom: 2vh;
    }
  }

  @keyframes rainbow {
    0% {
      background-position: 0% center;
    }
    100% {
      background-position: -200% center;
    }
  }

  @keyframes moveGradient {
    0% {
      background-position: 0% 50%;
    }
    100% {
      background-position: -200% 50%;
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes rainbowMove {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
  }

  @keyframes rippleExpand {
    0% {
      opacity: 0;
      transform: scale(0.15);
      filter: blur(2px);
    }
    20% {
      opacity: 1;
      transform: scale(1.3);
      filter: blur(0);
    }
    100% {
      opacity: 0;
      transform: scale(9);
      filter: blur(2px);
    }
  }

  @media (hover: none) and (pointer: coarse) {
    @keyframes rippleExpand {
      0% {
        opacity: 0;
        transform: scale(0.15);
      }
      20% {
        opacity: 1;
        transform: scale(1.3);
      }
      100% {
        opacity: 0;
        transform: scale(9);
      }
    }
  }

  @keyframes titleJiggle {
    0% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.15) rotate(3deg); }
    50% { transform: scale(1.075) rotate(-1.5deg); }
    75% { transform: scale(1.12) rotate(1.5deg); }
    100% { transform: scale(1) rotate(0deg); }
  }

  @media (hover: none) and (pointer: coarse) {
    @keyframes titleJiggle {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.3) rotate(6deg); }
      50% { transform: scale(1.15) rotate(-3deg); }
      75% { transform: scale(1.24) rotate(3deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
  }

  .jiggle {
    animation: titleJiggle 300ms ease-in-out;
  }

  .rainbow-color {
    background: linear-gradient(
      to right,
      red,
      orange,
      yellow,
      green,
      blue,
      indigo,
      violet,
      red
    );
    background-size: 200% 100%;
    animation: rainbowMove 10s linear infinite;
  }

  /* MP3 Generator Modal Styles */
  #mp3GeneratorModal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  }

  #mp3GeneratorModal.show {
    display: flex;
  }

  #mp3GeneratorContent {
    background-color: white;
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    position: relative;
  }

  #mp3GeneratorTitle {
    font-family: 'Baloo 2', sans-serif;
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #333;
    text-align: center;
  }

  #mp3GeneratorInput {
    width: 100%;
    padding: 12px;
    font-size: 16px;
    border: 2px solid #ddd;
    border-radius: 8px;
    margin-bottom: 15px;
    font-family: 'Baloo 2', sans-serif;
    box-sizing: border-box;
  }

  #mp3GeneratorInput:focus {
    outline: none;
    border-color: #4D96FF;
  }

  #mp3GeneratorButtons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
  }

  .mp3GeneratorButton {
    padding: 10px 20px;
    font-size: 16px;
    font-family: 'Baloo 2', sans-serif;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  #mp3GeneratorSubmit {
    background-color: #4D96FF;
    color: white;
  }

  #mp3GeneratorSubmit:hover {
    background-color: #3a7acc;
  }

  #mp3GeneratorSubmit:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  #mp3GeneratorClose {
    background-color: #f0f0f0;
    color: #333;
  }

  #mp3GeneratorClose:hover {
    background-color: #e0e0e0;
  }
</style>
</head>
<body>
<div id="introScreen">
  <div class="baloo-2-intro-title">Coloreka!</div>
  <div id="introRules"></div>
</div>
<div id="leftColor">
  <div class="colorLayer"></div>
</div>
<div id="rightColor">
  <div class="colorLayer"></div>
</div>

<!-- MP3 Generator Modal (Desktop Only) -->
<div id="mp3GeneratorModal">
  <div id="mp3GeneratorContent">
    <div id="mp3GeneratorTitle">Say anything and save as MP3!</div>
    <input type="text" id="mp3GeneratorInput" placeholder="Enter text to generate..." autocomplete="off">
    <div id="mp3GeneratorButtons">
      <button id="mp3GeneratorClose" class="mp3GeneratorButton">Close</button>
      <button id="mp3GeneratorSubmit" class="mp3GeneratorButton">Generate & Download</button>
    </div>
  </div>
</div>

<!-- Load lamejs for MP3 encoding when downloading audio files -->
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>

<script>
// TEMPORARILY DISABLED: 'green' and 'rainbow' colors
const colors = ['red', /* 'green', */ 'blue', 'yellow', 'purple'];
const rippleColors = ['#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#E964FF', '#FFA1C9'];
let currentLeftColor, currentRightColor;
let soundOn = true;
let touchStartTime = 0;
let touchCount = 0;
let longPressTimer;
let isTwoColorMode = false;
const LONG_PRESS_DURATION = 700; // milliseconds

// MP3 Generator Modal: Store last submission for session persistence
let lastMP3Submission = '';
let touchStartY = 0;
let isMobile = false;
let lastInteractionTime = 0;
const INTERACTION_COOLDOWN = 50; // 50ms cooldown between interactions
let isIntroScreen = true;
let introTapStarted = false;
let lastModeSwitchTime = 0;
const MODE_SWITCH_COOLDOWN = 300; // 300ms cooldown for mode switching
let isShiftKeyDown = false;
let colorChangesSinceIntro = 0;
let lastPointerPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let lastPointerRatio = { x: 0.5, y: 0.5 };
let rippleFollowHandle = null;
let lastSwishSound = null;
const swishSounds = ['audio/Swish (1).mp3', 'audio/Swish (2).mp3', 'audio/Swish (3).mp3', 'audio/Swish (4).mp3'];
// Coloreka cloud TTS service endpoint - provides high-quality text-to-speech with expressive voices
// Available as a standalone feature - can be called directly via speakWithCloudTTS(text)
// May be rate limited or unavailable, in which case the function will return false
const TTS_SERVICE_URL = 'https://steep-sound-5d19.hunterbobeck.workers.dev';

// Tracks the currently playing audio from the cloud TTS service
// Used to stop playback if a new voice request comes in (either cloud or device voice)
// This ensures only one voice plays at a time and prevents overlapping audio
let currentAIAudio = null;

/**
 * MP3 Audio File Management System
 * 
 * This system manages pre-recorded MP3 audio files for colors and menu statements.
 * Instead of using computer-generated speech, we play high-quality pre-recorded audio files.
 * 
 * HOW IT WORKS:
 * 1. Each color/menu item has multiple MP3 files (e.g., "Blue (1).mp3", "Blue (2).mp3", etc.)
 * 2. When a color is spoken, we randomly select one of its MP3 files
 * 3. We track which files have been played to ensure variety
 * 4. Once all files in a set have been played, we reshuffle and start a new cycle
 * 5. This ensures users hear all variations before any repeats, but in random order each cycle
 * 
 * DATA STRUCTURE:
 * - Key: Lowercase text identifier (e.g., 'blue', 'here are your controls')
 * - displayName: Exact filename format used in the actual MP3 files (e.g., 'Blue', 'Here are your controls')
 * - count: Total number of MP3 files available for this item (files are numbered 1 to count)
 * - played: Array tracking which file numbers have been played in the current cycle
 * - currentShuffle: Array of shuffled file numbers (1 to count) for the current cycle
 * 
 * EXAMPLE CYCLE FOR BLUE (7 files):
 * - Cycle 1: Shuffle might be [3, 7, 1, 5, 2, 4, 6] - plays all 7 files in random order
 * - Cycle 2: Shuffle might be [2, 6, 4, 1, 7, 3, 5] - plays all 7 files again, different order
 * 
 * TO ADD NEW COLORS/MENU ITEMS:
 * Simply add a new entry with the lowercase key, displayName, and count of available files.
 * Make sure the MP3 files exist in /audio/generated/ with the format: "{displayName} ({number}).mp3"
 */
const audioFileSets = {
  'blue': { displayName: 'Blue', count: 7, played: [], currentShuffle: [] },
  'green': { displayName: 'Green', count: 9, played: [], currentShuffle: [] },
  'purple': { displayName: 'Purple', count: 4, played: [], currentShuffle: [] },
  'rainbow': { displayName: 'Rainbow', count: 2, played: [], currentShuffle: [] },
  'red': { displayName: 'Red', count: 2, played: [], currentShuffle: [] },
  'yellow': { displayName: 'Yellow', count: 4, played: [], currentShuffle: [] },
  'here are your controls': { displayName: 'Here are your controls', count: 2, played: [], currentShuffle: [] }
};

/**
 * Checks if a given text has pre-recorded MP3 files available
 * 
 * This function determines whether we should use MP3 files or fall back to computer voice.
 * It checks if the text (normalized to lowercase) exists as a key in audioFileSets.
 * 
 * @param {string} text - The text to check (e.g., "Blue", "Here are your controls")
 * @returns {boolean} - True if MP3 files are available for this text, false otherwise
 * 
 * @example
 * hasAudioFiles("Blue") // returns true (we have Blue MP3s)
 * hasAudioFiles("muted") // returns false (no MP3s, will use computer voice)
 */
function hasAudioFiles(text) {
  // Normalize to lowercase to match audioFileSets keys
  // This handles variations like "Blue", "blue", "BLUE" all the same way
  const normalizedKey = text.toLowerCase();
  
  // Check if this key exists in our audio file sets
  return normalizedKey in audioFileSets;
}

/**
 * Creates a shuffled array of indices using Fisher-Yates shuffle algorithm
 * 
 * This function generates a random permutation of numbers from 1 to count.
 * Fisher-Yates is an efficient, unbiased shuffling algorithm that ensures
 * each possible permutation has equal probability.
 * 
 * @param {number} count - Number of items to shuffle (files are numbered 1 to count)
 * @returns {number[]} - Shuffled array of indices from 1 to count
 * 
 * @example
 * createShuffledIndices(4) // might return [3, 1, 4, 2] or [2, 4, 1, 3], etc.
 * createShuffledIndices(7) // might return [5, 2, 7, 1, 3, 6, 4], etc.
 */
function createShuffledIndices(count) {
  // Create array [1, 2, 3, ..., count] representing file numbers
  const indices = Array.from({ length: count }, (_, i) => i + 1);
  
  // Fisher-Yates shuffle: iterate backwards through array
  // For each position, swap with a random position from 0 to current position
  // This ensures each element has equal chance of ending up in any position
  for (let i = indices.length - 1; i > 0; i--) {
    // Pick a random index from 0 to i (inclusive)
    const j = Math.floor(Math.random() * (i + 1));
    
    // Swap elements at positions i and j
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  
  return indices;
}

/**
 * Gets the next random MP3 file for a given color or menu item
 * 
 * This is the core function that manages the shuffle-and-cycle system.
 * It ensures all MP3 files for an item are played before any repeats,
 * but plays them in a different random order each cycle.
 * 
 * HOW IT WORKS:
 * 1. Look up the audio file set for the given key
 * 2. Check if we've completed a full cycle (played all files)
 *    - If yes: Reset tracking arrays to start a new cycle
 * 3. Check if we need a new shuffle (currentShuffle is empty)
 *    - If yes: Create a new random shuffle of all file numbers
 * 4. Take the next file number from the shuffle
 * 5. Track that we've played this file number
 * 6. Build and return the full file path
 * 
 * EXAMPLE FLOW FOR BLUE (7 files):
 * - First call: currentShuffle=[], creates shuffle [3,7,1,5,2,4,6], returns "Blue (3).mp3"
 * - Second call: currentShuffle=[7,1,5,2,4,6], returns "Blue (7).mp3"
 * - ... continues until all 7 files played ...
 * - 8th call: played.length=7, resets, creates new shuffle [2,6,4,1,7,3,5], returns "Blue (2).mp3"
 * 
 * @param {string} key - The color name (lowercase) or menu text to get audio for
 * @returns {string|null} - Full path to the MP3 file (e.g., "audio/generated/Blue (3).mp3"), or null if not found
 */
function getNextAudioFile(key) {
  // Normalize key to lowercase to match audioFileSets keys
  const normalizedKey = key.toLowerCase();
  
  // Look up the audio file set configuration for this key
  const set = audioFileSets[normalizedKey];
  
  // Safety check: If no set found, log warning and return null
  // This should never happen if hasAudioFiles() was called first, but good to be safe
  if (!set) {
    console.warn(`No audio file set found for: ${key}`);
    return null;
  }
  
  // CYCLE MANAGEMENT: Check if we've completed a full cycle
  // A cycle is complete when we've played all files in the set
  if (set.played.length >= set.count) {
    // Reset tracking arrays to start a fresh cycle
    // This ensures we play all files again before any repeats
    set.played = [];
    set.currentShuffle = [];
  }
  
  // SHUFFLE MANAGEMENT: Check if we need to create a new shuffle
  // This happens at the start of each cycle (when currentShuffle is empty)
  if (set.currentShuffle.length === 0) {
    // Create a new random shuffle of all file numbers (1 to count)
    // Each cycle will have a different random order
    set.currentShuffle = createShuffledIndices(set.count);
  }
  
  // GET NEXT FILE: Take the first file number from the shuffle
  // shift() removes and returns the first element
  const fileNumber = set.currentShuffle.shift();
  
  // TRACK PLAYED: Record that we've played this file number in the current cycle
  // This helps us know when we've completed a full cycle
  set.played.push(fileNumber);
  
  // BUILD FILENAME: Use displayName from config to ensure correct filename format
  // Format: "{displayName} ({fileNumber}).mp3"
  // Example: "Blue (3).mp3" or "Here are your controls (1).mp3"
  const filename = `${set.displayName} (${fileNumber}).mp3`;
  
  // Return the full path to the MP3 file
  return `audio/generated/${filename}`;
}

/**
 * Plays an MP3 audio file for colors or menu statements
 * 
 * This function handles the actual playback of pre-recorded MP3 files.
 * It manages audio interruption, error handling, and cleanup to ensure
 * smooth playback and prevent overlapping audio.
 * 
 * HOW IT WORKS:
 * 1. Stop any currently playing audio (MP3 or computer voice) to prevent overlap
 * 2. Create a new Audio object with the file path
 * 3. Set volume to 25% (matching computer voice volume)
 * 4. Store reference so we can interrupt it if needed
 * 5. Set up error and cleanup handlers
 * 6. Start playback and return success status
 * 
 * ERROR HANDLING:
 * - If file doesn't exist or can't be loaded, error handler fires
 * - If playback fails, catch block handles it
 * - In both cases, we clear the reference and return false
 * - The caller (speak function) will fall back to computer voice
 * 
 * @param {string} filePath - Full path to the MP3 file (e.g., "audio/generated/Blue (3).mp3")
 * @returns {Promise<boolean>} - Returns true if audio started playing successfully, false on error
 */
async function playAudioFile(filePath) {
  try {
    // AUDIO INTERRUPTION: Stop any currently playing audio
    // This ensures only one audio source plays at a time
    // If a new color is spoken while another is playing, the old one stops immediately
    if (currentAIAudio) {
      currentAIAudio.pause();
      currentAIAudio.currentTime = 0; // Reset to beginning
      currentAIAudio = null; // Clear reference
    }
    
    // Also cancel any computer voice that might be playing
    // This prevents MP3 and computer voice from playing simultaneously
    speechSynthesis.cancel();
    
    // CREATE AUDIO OBJECT: Load the MP3 file
    // The browser will fetch the file from the specified path
    const audio = new Audio(filePath);
    
    // SET VOLUME: Match computer voice volume (25%)
    // This ensures consistent audio levels across all speech types
    audio.volume = 0.25;
    
    // STORE REFERENCE: Keep track of the currently playing audio
    // This allows us to interrupt it if a new speech request comes in
    // The reference is cleared when audio ends or errors
    currentAIAudio = audio;
    
    // ERROR HANDLER: Handle cases where file can't be loaded or played
    // This might happen if:
    // - File doesn't exist at the path
    // - File format is invalid
    // - Network error loading the file
    audio.addEventListener('error', (e) => {
      console.error(`Failed to play audio file: ${filePath}`, e);
      currentAIAudio = null; // Clear reference so new audio can play
    });
    
    // CLEANUP HANDLER: Clear reference when audio finishes naturally
    // This ensures the reference is cleared so new audio can play
    // { once: true } ensures this handler only fires once
    audio.addEventListener('ended', () => {
      currentAIAudio = null;
    }, { once: true });
    
    // START PLAYBACK: Begin playing the audio file
    // This is async because the browser needs to load and decode the file
    await audio.play();
    
    // SUCCESS: Audio started playing
    return true;
    
  } catch (error) {
    // CATCH ERRORS: Handle any errors during audio creation or playback
    // This might happen if:
    // - File path is invalid
    // - Browser doesn't support the audio format
    // - User interaction required (some browsers require user gesture)
    console.error(`Error playing audio file: ${filePath}`, error);
    
    // Clear reference so new audio can attempt to play
    currentAIAudio = null;
    
    // Return false to indicate failure
    // The caller will fall back to computer voice
    return false;
  }
}

/* DISABLED: Cloud TTS functionality - disabled due to high latency
// Debug function to test Worker directly - call testWorker() in console
window.testWorker = async function() {
  console.log('Testing Worker...');
  try {
    const response = await fetch(TTS_SERVICE_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: 'test' }),
    });
    console.log('Status:', response.status);
    console.log('Headers:', Object.fromEntries(response.headers.entries()));
    if (response.status === 200) {
      const blob = await response.blob();
      console.log('Success! Audio blob size:', blob.size, 'bytes');
    } else {
      const text = await response.text();
      console.log('Response body:', text);
    }
  } catch (error) {
    console.error('Error:', error);
  }
};
*/

function playAudio(src, volume = 0.05) {
  const audio = new Audio(src);
  audio.volume = volume;
  audio.play().catch(err => {
    console.log(`Error playing sound: ${err.message}`);
  });
}

function setLayerColor(layer, color) {
  if (!layer) return;
  layer.classList.remove('rainbow-color');
  if (color === 'rainbow') {
    layer.classList.add('rainbow-color');
    layer.style.backgroundColor = '';
  } else if (color === 'purple') {
    // Map purple to bright magenta (#FF00FF) for more vivid color
    layer.style.backgroundColor = '#FF00FF';
  } else {
    layer.style.backgroundColor = color;
  }
}

function getRandomColor(currentLeftColor, currentRightColor) {
  let newColor;
  do {
    // TEMPORARILY DISABLED: Rainbow color selection
    // Only allow rainbow after 5 changes since intro
    // if (colorChangesSinceIntro > 5 && Math.random() < 0.025) {
    //   newColor = 'rainbow';
    // } else {
      newColor = colors[Math.floor(Math.random() * colors.length)];
    // }
  } while (newColor === currentLeftColor || newColor === currentRightColor);
  return newColor;
}

function changeColors() {
  if (isIntroScreen) return;

  const currentTime = new Date().getTime();
  if (currentTime - lastInteractionTime < INTERACTION_COOLDOWN) {
    return;
  }
  lastInteractionTime = currentTime;

  const previousLeftColor = currentLeftColor;
  const previousRightColor = currentRightColor;
  
  currentLeftColor = getRandomColor(currentLeftColor, currentRightColor);
  currentRightColor = getRandomColor(currentLeftColor, currentRightColor);

  colorChangesSinceIntro++; // Increment counter

  applyTransition('leftColor', currentLeftColor);
  if (isTwoColorMode) {
    applyTransition('rightColor', currentRightColor);
  }

  // Play swish sound when advancing
  playSwishSound();

  // Gentle vibration when advancing
  vibrateGentle();

  if (soundOn) {
    if (isTwoColorMode) {
      speak(`${previousLeftColor} and ${previousRightColor}`, true); // Always use device voice in two color mode
    } else {
      speak(previousLeftColor);
    }
  }

  requestFullscreen();
}

function applyTransition(elementId, newColor) {
  const container = document.getElementById(elementId);
  const currentLayer = container.querySelector('.colorLayer');
  const newLayer = document.createElement('div');

  newLayer.className = 'wipe-transition';
  setLayerColor(newLayer, newColor);

  const effects = ['slide', 'zoom', 'rotate', 'curl', 'spin'];
  const effect = effects[Math.floor(Math.random() * effects.length)];
  
  switch(effect) {
    case 'slide':
      applySlideTransition(newLayer);
      break;
    case 'zoom':
      newLayer.style.transform = 'scale(0)';
      newLayer.style.opacity = '0';
      break;
    case 'rotate':
      newLayer.style.transform = 'rotate(-180deg) scale(0)';
      newLayer.style.opacity = '0';
      break;
    case 'curl':
      applyCurlTransition(newLayer);
      break;
    case 'spin':
      applySpinTransition(newLayer);
      break;
  }
  
  container.appendChild(newLayer);
  
  setTimeout(() => {
    switch(effect) {
      case 'slide':
        newLayer.style.transform = 'translate(0, 0)';
        break;
      case 'zoom':
        newLayer.style.transform = 'scale(1)';
        newLayer.style.opacity = '1';
        break;
      case 'rotate':
        newLayer.style.transform = 'rotate(0) scale(1)';
        newLayer.style.opacity = '1';
        break;
      case 'curl':
        newLayer.style.transform = 'perspective(1000px) rotateY(0deg)';
        newLayer.style.opacity = '1';
        break;
      case 'spin':
        newLayer.style.transform = 'rotate(0deg) scale(1)';
        newLayer.style.opacity = '1';
        break;
    }
  }, 50);
  
  setTimeout(() => {
    currentLayer.remove();
    newLayer.className = 'colorLayer';
    setLayerColor(newLayer, newColor);
  }, 550);
}

function applySpinTransition(newLayer) {
  newLayer.style.transformOrigin = 'center center';
  newLayer.style.transform = 'rotate(720deg) scale(0)';
  newLayer.style.opacity = '0';
}

function applyCurlTransition(newLayer) {
  newLayer.style.transformOrigin = 'bottom right';
  newLayer.style.transform = 'perspective(1000px) rotateY(-90deg)';
  newLayer.style.opacity = '0';
}

function applySlideTransition(newLayer) {
  const directions = ['Left', 'Right', 'Top', 'Bottom'];
  const direction = directions[Math.floor(Math.random() * directions.length)];
  
  switch(direction) {
    case 'Left':
      newLayer.style.transform = 'translateX(100%)';
      break;
    case 'Right':
      newLayer.style.transform = 'translateX(-100%)';
      break;
    case 'Top':
      newLayer.style.transform = 'translateY(100%)';
      break;
    case 'Bottom':
      newLayer.style.transform = 'translateY(-100%)';
      break;
  }
}

function applyFadeTransition(elementId, newColor) {
  const container = document.getElementById(elementId);
  const currentLayer = container.querySelector('.colorLayer');
  const newLayer = document.createElement('div');

  newLayer.className = 'colorLayer';
  setLayerColor(newLayer, newColor);
  
  newLayer.style.opacity = '0';
  container.appendChild(newLayer);
  
  setTimeout(() => {
    newLayer.style.opacity = '1';
    currentLayer.style.opacity = '0';
  }, 50);
  
  setTimeout(() => {
    currentLayer.remove();
  }, 550);
}

function startApp() {
  if (isIntroScreen) {
    isIntroScreen = false;
    document.getElementById('introScreen').style.display = 'none';
    currentLeftColor = getRandomColor();
    currentRightColor = getRandomColor(currentLeftColor);
    applyFadeTransition('leftColor', currentLeftColor);
    requestFullscreen();

    // Play gong sound when advancing from menu
    playGongSound();
  }
}

/**
 * Cloud AI Voice Generation - Standalone Feature
 * 
 * This function provides access to high-quality AI voice generation from the cloud.
 * It is currently available as a standalone feature and can be called directly.
 * 
 * USAGE:
 *   const success = await speakWithCloudTTS("Hello, world!");
 *   if (success) {
 *     // Audio is playing
 *   } else {
 *     // Failed - handle fallback if needed
 *   }
 * 
 *   // With download enabled:
 *   await speakWithCloudTTS("Hello, world!", true);
 * 
 * FEATURES:
 * - High-quality AI-generated speech with expressive tone tags
 * - Automatic fade-out to avoid trailing sounds
 * - Audio interruption handling (stops previous audio when new request comes in)
 * - Error handling with timing information
 * - Optional audio file download when playback starts
 * 
 * NOTE: This function is not currently hooked up to the main speak() function.
 * It's available as a standalone feature for future integration.
 * 
 * @param {string} text - The text to convert to speech
 * @param {boolean} downloadAudio - If true, downloads the audio file when playback starts (default: false)
 * @returns {Promise<boolean>} - Returns true if audio started playing successfully, false otherwise
 */
async function speakWithCloudTTS(text, downloadAudio = false) {
  // Voice interruption: Stop any currently playing cloud TTS audio
  // This ensures that if a new voice request comes in while audio is playing,
  // the old audio stops immediately so the new one can start
  if (currentAIAudio) {
    currentAIAudio.pause();
    currentAIAudio.currentTime = 0;
    currentAIAudio = null;
  }
  
  // Voice interruption: Cancel any currently playing device voice
  // This ensures cloud TTS audio can interrupt device voice playback
  speechSynthesis.cancel();
  
  // Track timing: Record when the request starts to measure response time
  const requestStartTime = Date.now();
  
  try {
    // Text transformation: Special handling for app title
    // When the app title is spoken, replace it with a more descriptive phrase
    // This provides better context for users learning the controls
    if (text === 'Coloreka!' || text === 'Coloreka') {
      text = 'Here are your controls';
    }
    
    // Tone enhancement: Add expressive vocal direction tags
    // The cloud TTS service supports tone modifiers in square brackets that affect
    // how the voice sounds - making it more cheerful, encouraging, or friendly
    // This creates a more engaging and supportive experience for users learning colors
    const toneTags = ['[cheerful]', '[encouraging]', '[friendly]'];
    const randomTone = toneTags[Math.floor(Math.random() * toneTags.length)];
    
    // Content detection: Determine if the text is a color name
    // Color names get special treatment with prefixes, while other text (like instructions)
    // gets simpler formatting
    // TEMPORARILY DISABLED: 'green' and 'rainbow' in colorNames
    // Note: 'purple' is pronounced as 'magenta' via conversion in speak() function
    const colorNames = ['red', /* 'green', */ 'blue', 'yellow', 'purple', /* 'rainbow' */];
    const isColor = colorNames.includes(text.toLowerCase());
    
    // Text enhancement: Add prefixes and exclamation points for more engaging speech
    // For colors: Randomly select from weighted prefix options to add variety
    //   - Empty prefix (just color name): ~27% chance - creates simple, direct statements
    //   - "It was": ~27% chance - common, natural phrasing
    //   - "That was": ~27% chance - common, natural phrasing  
    //   - "The color was": ~9% chance - more descriptive, used less frequently
    //   - "That one was": ~9% chance - more descriptive, used less frequently
    // For non-colors: Just add tone tag and exclamation point (no prefix)
    // All text gets an exclamation point for enthusiastic delivery
    let excitedText;
    if (isColor) {
      // TEMPORARILY DISABLED: Prefixes for color pronunciation
      // Weighted array: More instances of a prefix = higher probability of selection
      // This creates natural variation while favoring more common phrases
      // const prefixes = ['', '', '', 'It was ', 'It was ', 'It was ', 'That was ', 'That was ', 'That was ', 'The color was ', 'That one was '];
      // const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      
      // Spacing handling: If prefix is empty, don't add extra space after tone tag
      // This ensures proper formatting whether prefix is present or not
      // if (randomPrefix === '') {
      //   excitedText = randomTone + ' ' + text + '!';
      // } else {
      //   excitedText = randomTone + ' ' + randomPrefix + text + '!';
      // }
      
      // Temporary: No prefix, just tone tag and color name with exclamation
      excitedText = randomTone + ' ' + text + '.!';
    } else {
      // For non-color text (like instructions), just add tone tag and exclamation point
      // No prefix is added to keep the message clear and direct
      excitedText = randomTone + ' ' + text + '.!';
    }
    
    // Request audio from the Coloreka cloud TTS service
    // The service processes the enhanced text (with tone tags and prefixes) and returns audio data
    const response = await fetch(TTS_SERVICE_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text: excitedText,
        model: 'canopylabs/orpheus-v1-english',
        voice: 'hannah',
        response_format: 'wav'
      }),
    });

    // Success case: Cloud TTS service returned audio data (status 200)
    // Process the audio and play it with fade-out to avoid trailing sounds
    if (response.status === 200) {
      // Convert the response to an audio blob that can be played
      const audioBlob = await response.blob();
      
      // Optional download: If downloadAudio is true, convert WAV to MP3 and download
      if (downloadAudio) {
        try {
          // Convert WAV to MP3 using Web Audio API and lamejs
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const arrayBuffer = await audioBlob.arrayBuffer();
          const audioData = await audioContext.decodeAudioData(arrayBuffer);
          
          // Get audio samples (mono or stereo)
          const sampleRate = audioData.sampleRate;
          const numChannels = audioData.numberOfChannels;
          const length = audioData.length;
          
          // Convert float samples to 16-bit PCM
          // For stereo, interleave channels (L, R, L, R, ...)
          let samples16bit;
          if (numChannels === 2) {
            const leftChannel = audioData.getChannelData(0);
            const rightChannel = audioData.getChannelData(1);
            samples16bit = new Int16Array(length * 2);
            for (let i = 0; i < length; i++) {
              samples16bit[i * 2] = Math.max(-32768, Math.min(32767, leftChannel[i] * 32768));
              samples16bit[i * 2 + 1] = Math.max(-32768, Math.min(32767, rightChannel[i] * 32768));
            }
          } else {
            const samples = audioData.getChannelData(0);
            samples16bit = new Int16Array(length);
            for (let i = 0; i < length; i++) {
              samples16bit[i] = Math.max(-32768, Math.min(32767, samples[i] * 32768));
            }
          }
          
          // Encode to MP3 using lamejs
          const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, 128); // 128 kbps
          const sampleBlockSize = numChannels === 2 ? 1152 * 2 : 1152; // Stereo needs 2x samples
          const mp3Data = [];
          
          for (let i = 0; i < samples16bit.length; i += sampleBlockSize) {
            const sampleChunk = samples16bit.subarray(i, i + sampleBlockSize);
            const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
            if (mp3buf.length > 0) {
              mp3Data.push(mp3buf);
            }
          }
          
          // Flush encoder
          const mp3buf = mp3encoder.flush();
          if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
          }
          
          // Create MP3 blob
          const mp3Blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          
          const timestamp = Date.now();
          // Sanitize text for filename: remove special characters, limit length, replace spaces
          const sanitizedText = text
            .replace(/[^a-zA-Z0-9\s]/g, '') // Remove special characters
            .replace(/\s+/g, '_') // Replace spaces with underscores
            .substring(0, 50); // Limit length
          const filename = `audio/generated/${timestamp}_${sanitizedText}.mp3`;
          
          // Create download link and trigger download
          const downloadUrl = URL.createObjectURL(mp3Blob);
          const downloadLink = document.createElement('a');
          downloadLink.href = downloadUrl;
          downloadLink.download = filename;
          downloadLink.style.display = 'none';
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          URL.revokeObjectURL(downloadUrl);
        } catch (downloadError) {
          console.error('Failed to download audio file:', downloadError);
          // Continue with playback even if download fails
        }
      }
      
      // Create a temporary URL for the audio blob so it can be played
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      audio.volume = 0.25;
      
      // Store reference to the audio object
      // This allows us to stop playback if a new voice request comes in
      // The reference is cleared when audio finishes or is stopped
      currentAIAudio = audio;
      
      // Add error handler for audio playback
      audio.addEventListener('error', (e) => {
        currentAIAudio = null; // Clear reference on error
      });
      
      // Start playing the audio
      await audio.play();
      
      // Fade-out system: Smoothly reduce volume before the end to avoid trailing sounds
      // Some audio files may contain unwanted sounds (sighs, snorts, etc.) at the very end
      // By fading out slightly before the audio naturally ends, we cut off these artifacts
      // while maintaining a smooth, natural-sounding conclusion
      let isFadingOut = false;
      const originalVolume = audio.volume; // Store original volume to restore for next playback
      
      // Monitor audio playback progress to trigger fade-out at the right time
      audio.addEventListener('timeupdate', () => {
        // Trigger fade-out when we're 200ms away from the end of the audio
        // This gives us enough time to smoothly fade out before any trailing sounds
        if (!isFadingOut && audio.duration && audio.currentTime >= audio.duration - 0.2) {
          isFadingOut = true; // Mark that fade-out has started to prevent duplicate triggers
          
          // Fade-out parameters: Reduce volume to zero over 150ms
          // This creates a smooth transition that's fast enough to cut off artifacts
          // but slow enough to sound natural
          const fadeOutDuration = 0.15;
          const fadeOutStartTime = audio.currentTime;
          const fadeOutStartVolume = audio.volume;
          
          // Smooth fade-out: Update volume every 10ms for fluid transition
          // This creates a gradual volume reduction rather than an abrupt stop
          const fadeOutInterval = setInterval(() => {
            // Safety check: If audio was stopped externally, clean up and exit
            if (audio.paused || audio.ended) {
              clearInterval(fadeOutInterval);
              return;
            }
            
            // Calculate how far through the fade-out we are (0 to 1)
            const elapsed = audio.currentTime - fadeOutStartTime;
            if (elapsed >= fadeOutDuration) {
              // Fade-out complete: Stop playback and clean up resources
              audio.pause();
              audio.currentTime = 0;
              audio.volume = originalVolume; // Reset volume for next playback
              clearInterval(fadeOutInterval);
              currentAIAudio = null; // Clear reference so new audio can play
              URL.revokeObjectURL(audioUrl); // Free up memory from blob URL
            } else {
              // Gradually reduce volume: Linear fade from start volume to zero
              // Progress goes from 0 (start) to 1 (end), so (1 - progress) goes from 1 to 0
              const progress = elapsed / fadeOutDuration;
              audio.volume = fadeOutStartVolume * (1 - progress);
            }
          }, 10); // Update every 10ms for smooth fade (100 updates over 1 second)
        }
      });
      
      // Cleanup handler: If audio finishes naturally without fade-out triggering
      // This handles edge cases where audio might be shorter than expected
      // or if fade-out logic doesn't trigger for some reason
      audio.addEventListener('ended', () => {
        if (!isFadingOut) {
          audio.volume = originalVolume; // Reset volume for next playback
          currentAIAudio = null; // Clear reference so new audio can play
          URL.revokeObjectURL(audioUrl); // Free up memory from blob URL
        }
      }, { once: true }); // Only fire once to prevent duplicate cleanup
      
      // Return success: Audio is now playing
      return true;
    } else {
      // Non-success response: Cloud TTS service returned an error status
      // This could be due to rate limiting, service unavailability, or invalid request
      // Calculate and log response time
      const responseTime = Date.now() - requestStartTime;
      console.log(`Cloud TTS error after ${responseTime}ms`);
      await response.text(); // Consume response body
    }
  } catch (error) {
    // Network or request error: Failed to communicate with cloud TTS service
    // This could be due to network issues, CORS problems, or service downtime
    // Calculate and log response time
    const responseTime = Date.now() - requestStartTime;
    console.log(`Cloud TTS error after ${responseTime}ms`);
  }
  
  // Failure case: Return false to indicate cloud TTS did not succeed
  // The caller can handle fallback if needed
  return false;
}

/**
 * Main speech function: Converts text to speech using pre-recorded MP3s or device voice.
 * 
 * This is the main entry point for all speech in the application.
 * It decides whether to use pre-recorded MP3 files or computer-generated voice
 * based on the text content and context.
 * 
 * DECISION LOGIC:
 * 1. Two-color mode (useDeviceVoiceOnly=true): Always uses device voice
 *    - Example: "red and blue" → device voice
 * 2. Status messages (useDeviceVoiceOnly=true): Always uses device voice
 *    - Example: "muted", "Saying the colors" → device voice
 * 3. Colors in single color mode: Uses MP3 files if available
 *    - Example: "blue" → plays "Blue (3).mp3" (random file from set)
 * 4. Menu statements: Uses MP3 files if available
 *    - Example: "Coloreka!" → converts to "Here are your controls" → plays MP3
 * 5. Fallback: If MP3 fails to load/play, falls back to device voice
 * 
 * MP3 INTEGRATION:
 * - Checks if MP3 files exist for the text using hasAudioFiles()
 * - Gets next random file using getNextAudioFile() (manages shuffle/cycle)
 * - Plays the file using playAudioFile() (handles playback and errors)
 * - Falls back to device voice if MP3 playback fails
 * 
 * @param {string} text - The text to convert to speech (e.g., "blue", "Coloreka!", "muted")
 * @param {boolean} useDeviceVoiceOnly - If true, forces device voice (used for two-color mode and status messages)
 * 
 * @example
 * speak("blue") // Plays random Blue MP3 file
 * speak("red and blue", true) // Uses device voice (two-color mode)
 * speak("muted", true) // Uses device voice (status message)
 */
async function speak(text, useDeviceVoiceOnly = false) {
  // AUDIO INTERRUPTION: Stop any currently playing audio
  // This ensures that when a new speech request comes in, any old audio stops immediately
  // This prevents overlapping voices and ensures only the most recent request plays
  // This is important because users might click colors rapidly
  if (currentAIAudio) {
    currentAIAudio.pause();
    currentAIAudio.currentTime = 0; // Reset to beginning
    currentAIAudio = null; // Clear reference
  }
  
  // VOICE INTERRUPTION: Cancel any currently playing device voice
  // This ensures new requests can interrupt old ones
  // This handles both MP3 interrupting device voice and vice versa
  speechSynthesis.cancel();
  
  // TEXT NORMALIZATION: Handle menu statement conversion
  // The app title "Coloreka!" is converted to "Here are your controls"
  // This matches the actual MP3 filename format
  if (text === 'Coloreka!' || text === 'Coloreka') {
    text = 'Here are your controls';
  }
  
  // TEMPORARY: Force device voice for 'purple' (magenta) since MP3s are for "Purple" pronunciation
  // This ensures "magenta" is spoken correctly instead of using old "Purple" MP3s
  if (text.toLowerCase() === 'purple') {
    useDeviceVoiceOnly = true;
  }
  
  // MP3 FILE CHECK: Determine if we should use pre-recorded MP3 files
  // Conditions:
  // 1. NOT forced to use device voice (useDeviceVoiceOnly = false)
  // 2. MP3 files exist for this text (hasAudioFiles returns true)
  // 
  // This means:
  // - Single color mode colors → use MP3s
  // - Menu statements → use MP3s
  // - Two-color mode → skip MP3s, use device voice
  // - Status messages → skip MP3s, use device voice
  if (!useDeviceVoiceOnly && hasAudioFiles(text)) {
    // MP3 FILE PLAYBACK: Use pre-recorded MP3 files
    
    // Normalize text to lowercase for lookup (audioFileSets uses lowercase keys)
    const normalizedText = text.toLowerCase();
    
    // Get the next random MP3 file for this text
    // This function manages the shuffle/cycle system to ensure variety
    const audioFile = getNextAudioFile(normalizedText);
    
    if (audioFile) {
      // Attempt to play the MP3 file
      const success = await playAudioFile(audioFile);
      
      if (success) {
        // SUCCESS: MP3 is playing, we're done
        // The playAudioFile function handles all playback, error handling, and cleanup
        return;
      }
      
      // FALLBACK: MP3 failed to play (file missing, format error, etc.)
      // Log warning and fall through to device voice as backup
      // This ensures users always get speech, even if MP3 files have issues
      console.warn(`Failed to play MP3 for "${text}", falling back to device voice`);
    }
  }
  
  // DEVICE VOICE FALLBACK: Use computer-generated voice
  // This is used for:
  // - Two-color mode (forced via useDeviceVoiceOnly=true)
  // - Status messages (forced via useDeviceVoiceOnly=true)
  // - Fallback when MP3 files fail to play
  // 
  // DISABLED NOTE: Computer voice for colors and menu statements is now disabled
  // in favor of MP3 files, but still used as fallback and for special cases
  
  // PRONUNCIATION CONVERSION: Convert 'purple' to 'magenta' for device voice
  // This ensures the color is pronounced as "magenta" even though the code uses 'purple' as the identifier
  let textToSpeak = text;
  if (text.toLowerCase() === 'purple') {
    textToSpeak = 'magenta';
  }
  
  const utterance = new SpeechSynthesisUtterance(textToSpeak);
  utterance.volume = 0.25; // Match MP3 volume level
  speechSynthesis.speak(utterance);
}

function playSwishSound() {
  let availableSounds = swishSounds.filter(sound => sound !== lastSwishSound);
  const randomSound = availableSounds[Math.floor(Math.random() * availableSounds.length)];
  lastSwishSound = randomSound;

  playAudio(randomSound);
}

function playGongSound() {
  playAudio('audio/Gong.mp3');
}

function vibrateGentle() {
  if ('vibrate' in navigator) {
    navigator.vibrate(100); // 100ms vibration for better noticeability
  }
}

function toggleSound() {
  soundOn = !soundOn;
  speak(soundOn ? "Saying the colors" : "muted", true); // Always use device voice for status messages
}

function updatePointerPosition(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) return;
  const clampedX = Math.max(0, Math.min(window.innerWidth, x));
  const clampedY = Math.max(0, Math.min(window.innerHeight, y));
  lastPointerPosition = { x: clampedX, y: clampedY };
  lastPointerRatio = {
    x: window.innerWidth ? clampedX / window.innerWidth : 0,
    y: window.innerHeight ? clampedY / window.innerHeight : 0
  };
}

function getPointerPositionFromRatio() {
  return {
    x: window.innerWidth * lastPointerRatio.x,
    y: window.innerHeight * lastPointerRatio.y
  };
}

function positionRipplesAt(x, y) {
  document.querySelectorAll('.ripple').forEach(ripple => {
    const size = parseFloat(ripple.dataset.size) || ripple.offsetWidth || 0;
    if (!size) return;
    ripple.style.left = `${x - size / 2}px`;
    ripple.style.top = `${y - size / 2}px`;
  });
}

function jiggleTitle() {
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.classList.remove('title-fade-in');
    title.style.opacity = '1';
    title.classList.add('jiggle');
    setTimeout(() => title.classList.remove('jiggle'), 300);
  }
}

function celebrateIntroScreen() {
  jiggleTitle();
  if (soundOn) {
    speak("Coloreka!");
  }
}

function followRipplesToPointer() {
  positionRipplesAt(lastPointerPosition.x, lastPointerPosition.y);
  if (document.querySelector('.ripple')) {
    rippleFollowHandle = window.requestAnimationFrame(followRipplesToPointer);
  } else {
    rippleFollowHandle = null;
  }
}

function ensureRippleFollowerRunning() {
  if (rippleFollowHandle !== null) return;
  rippleFollowHandle = window.requestAnimationFrame(followRipplesToPointer);
}

function repositionRipplesToLastPointer() {
  const { x, y } = getPointerPositionFromRatio();
  lastPointerPosition = { x, y };
  positionRipplesAt(x, y);
}

function createRipple(x, y, followPointer = true) {
  if (typeof x !== 'number' || typeof y !== 'number') return;

  updatePointerPosition(x, y);

  const ripple = document.createElement('div');
  ripple.className = 'ripple';

  const size = 40 + Math.random() * 60;
  ripple.style.width = `${size}px`;
  ripple.style.height = `${size}px`;
  ripple.style.left = `${x - size / 2}px`;
  ripple.style.top = `${y - size / 2}px`;
  ripple.dataset.size = size;

  const color = 'white';
  ripple.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
  
  // Simpler shadow for mobile
  if (isMobile) {
    ripple.style.boxShadow = `0 0 15px ${color}`;
  } else {
    ripple.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
  }

  document.body.appendChild(ripple);
  if (followPointer && !isMobile) {
    ensureRippleFollowerRunning();
  }
  setTimeout(() => ripple.remove(), 850);
}

function toggleTwoColorMode() {
  const currentTime = new Date().getTime();
  if (currentTime - lastModeSwitchTime < MODE_SWITCH_COOLDOWN) {
    return;
  }
  lastModeSwitchTime = currentTime;

  isTwoColorMode = !isTwoColorMode;
  const rightColorElement = document.getElementById('rightColor');
    if (isTwoColorMode) {
      rightColorElement.style.display = 'block';
      if (!currentRightColor || currentRightColor === currentLeftColor) {
        currentRightColor = getRandomColor(currentLeftColor, currentLeftColor);
      }
      setLayerColor(rightColorElement.querySelector('.colorLayer'), currentRightColor);
    } else {
      rightColorElement.style.display = 'none';
    }
}

function returnToIntro() {
  isIntroScreen = true;
  colorChangesSinceIntro = 0; // Reset counter
  const introScreen = document.getElementById('introScreen');
  introScreen.style.display = 'flex';
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.style.opacity = '1';
    title.classList.remove('title-fade-in');
  }
  jiggleTitle();
  const introRules = document.getElementById('introRules');
  introRules.style.animation = 'none';
  introRules.offsetHeight; // Trigger reflow
  introRules.style.animation = null;
  document.getElementById('leftColor').innerHTML = '<div class="colorLayer"></div>';
  document.getElementById('rightColor').innerHTML = '<div class="colorLayer"></div>';
  document.getElementById('rightColor').style.display = 'none';
  isTwoColorMode = false;
  currentLeftColor = undefined;
  currentRightColor = undefined;
  if (soundOn) {
    speak("Coloreka!");
  }
}

function checkMobile() {
  // Improved mobile detection that handles modern iPads (iPadOS 13+)
  // Modern iPads report as Macintosh in user agent, so we need additional checks
  
  const ua = navigator.userAgent;
  
  // Standard mobile device check (includes Android phones/tablets, older iPads, etc.)
  // Android tablets will be caught here since they have "Android" in user agent
  const isStandardMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  
  // Check for modern iPad (iPadOS 13+)
  // These report as MacIntel platform with Macintosh user agent but have:
  // - maxTouchPoints > 1 (indicates multi-touch capability, iPads typically have 5+)
  // - Touch event support
  const isModernIPad = navigator.platform === 'MacIntel' && 
                       navigator.maxTouchPoints > 1 &&
                       'ontouchstart' in window;
  
  // Fallback for Android tablets with unusual user agents (rare edge case)
  // Some custom browsers might not include "Android" but still have Android-like characteristics
  const isAndroidTabletFallback = navigator.platform === 'Linux armv7l' || 
                                  navigator.platform === 'Linux aarch64' ||
                                  (navigator.platform.startsWith('Linux') && 
                                   navigator.maxTouchPoints > 1 &&
                                   'ontouchstart' in window);
  
  // Consider it mobile if it's a standard mobile device, modern iPad, or Android tablet fallback
  isMobile = isStandardMobile || isModernIPad || isAndroidTabletFallback;
  
  updateIntroRules();
}

function updateIntroRules() {
  const introRules = document.getElementById('introRules');
  const alsoPlaysText = isMobile ? '' : '<div class="also-plays-text">🤳 Also plays on mobile!</div>';
  introRules.innerHTML = `
    ${alsoPlaysText}
    <h3>${isMobile ? '🤳 Mobile Controls!' : '🖥️ Desktop Controls!'}</h3>
    <ul>
      <li>▶️ <strong>Advance</strong>! ${isMobile ? '<i>Tap</i>' : '<i>Click</i> on the screen, press <i>Enter</i>, or press <i>Spacebar</i>'}</li>
      <li>🔄 <strong>Switch between single/two-color mode</strong>! ${isMobile ? '<i>Two-finger tap</i>' : 'Press the <i>Shift</i> key'}</li>
      <li>🔊 <strong>Toggle saying the colors</strong>! ${isMobile ? '<i>Long press</i>' : "Press the <i>S</i> key"}</li>
      <li>📜 <strong>Show these instructions</strong>! ${isMobile ? '<i>Three-finger tap</i>' : 'Press <i>Escape</i>'}</li>
    </ul>
  `;
}

function requestFullscreen() {
  const element = document.documentElement;
  if (element.requestFullscreen) {
    element.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else if (element.mozRequestFullScreen) { // Firefox
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) { // Chrome, Safari and Opera
    element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) { // IE/Edge
    element.msRequestFullscreen();
  }
}

document.body.addEventListener('mousedown', (event) => {
  if (isMobile) {
    return;
  }

  // Block app controls if MP3 generator modal is open
  if (isMP3GeneratorModalOpen()) {
    return;
  }

  createRipple(event.clientX, event.clientY);

  if (isIntroScreen) {
    startApp();
  } else {
    changeColors();
  }
});

// MP3 Generator Modal Functions
function isMP3GeneratorModalOpen() {
  const modal = document.getElementById('mp3GeneratorModal');
  return modal && modal.classList.contains('show');
}

function showMP3GeneratorModal() {
  if (isMobile) return; // Desktop only feature
  
  const modal = document.getElementById('mp3GeneratorModal');
  const input = document.getElementById('mp3GeneratorInput');
  
  // Pre-fill with last submission if available
  if (lastMP3Submission) {
    input.value = lastMP3Submission;
  } else {
    input.value = '';
  }
  
  modal.classList.add('show');
  input.focus();
  input.select(); // Select all text for easy replacement
}

function hideMP3GeneratorModal() {
  const modal = document.getElementById('mp3GeneratorModal');
  modal.classList.remove('show');
}

async function handleMP3GeneratorSubmit() {
  const input = document.getElementById('mp3GeneratorInput');
  const submitButton = document.getElementById('mp3GeneratorSubmit');
  const text = input.value.trim();
  
  if (!text) {
    alert('Please enter some text to generate.');
    return;
  }
  
  // Disable submit button during generation
  submitButton.disabled = true;
  submitButton.textContent = 'Generating...';
  
  try {
    // Store the submission for next time
    lastMP3Submission = text;
    
    // Call cloud TTS with download enabled
    await speakWithCloudTTS(text, true);
    
    // Re-enable button after a short delay
    setTimeout(() => {
      submitButton.disabled = false;
      submitButton.textContent = 'Generate & Download';
    }, 1000);
  } catch (error) {
    console.error('Error generating MP3:', error);
    alert('Error generating MP3. Please try again.');
    submitButton.disabled = false;
    submitButton.textContent = 'Generate & Download';
  }
}

// Initialize MP3 Generator Modal event listeners
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('mp3GeneratorModal');
  const input = document.getElementById('mp3GeneratorInput');
  const submitButton = document.getElementById('mp3GeneratorSubmit');
  const closeButton = document.getElementById('mp3GeneratorClose');
  
  // Close button
  closeButton.addEventListener('click', hideMP3GeneratorModal);
  
  // Submit button
  submitButton.addEventListener('click', handleMP3GeneratorSubmit);
  
  // Submit on Enter key
  input.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
      event.preventDefault();
      handleMP3GeneratorSubmit();
    } else if (event.key === 'Escape') {
      event.preventDefault();
      hideMP3GeneratorModal();
    }
  });
  
  // Close modal when clicking outside
  modal.addEventListener('click', (event) => {
    if (event.target === modal) {
      hideMP3GeneratorModal();
    }
  });
});

document.addEventListener('keydown', (event) => {
  if (!isMobile) {
    // Allow Quote and Escape keys to work even when modal is open
    // (Quote opens modal, Escape closes it or returns to intro)
    if (event.code === 'Quote') {
      event.preventDefault(); // Prevent apostrophe from being typed into input field
      if (isMP3GeneratorModalOpen()) {
        hideMP3GeneratorModal();
      } else {
        showMP3GeneratorModal();
      }
      return;
    }
    
    // Block all other app controls if MP3 generator modal is open
    if (isMP3GeneratorModalOpen()) {
      return;
    }
    
    switch (event.code) {
      case 'Enter':
      case 'Space':
        if (isIntroScreen) {
          startApp();
        } else {
          changeColors();
        }
        break;
      case 'KeyS':
        toggleSound(); // Allow sound toggling on intro screen
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        if (!isIntroScreen && !isShiftKeyDown) {
          isShiftKeyDown = true;
          toggleTwoColorMode();
        }
        break;
      case 'Escape':
        if (!isIntroScreen) {
          returnToIntro();
        } else {
          celebrateIntroScreen();
        }
        break;
    }
  }
});

document.addEventListener('mousemove', (event) => {
  if (isMobile) {
    return;
  }
  updatePointerPosition(event.clientX, event.clientY);
});

document.addEventListener('keyup', (event) => {
  if (!isMobile) {
    // Block app controls if MP3 generator modal is open
    if (isMP3GeneratorModalOpen()) {
      return;
    }
    
    switch (event.code) {
      case 'ShiftLeft':
      case 'ShiftRight':
        isShiftKeyDown = false;
        break;
    }
  }
});

document.body.addEventListener('touchstart', (event) => {
  // Block app controls if MP3 generator modal is open
  if (isMP3GeneratorModalOpen()) {
    return;
  }
  
  event.preventDefault();
  touchStartTime = new Date().getTime();
  touchCount = event.touches.length;
  isLongPress = false;
  touchStartY = event.touches[0].clientY;

  if (isIntroScreen) {
    introTapStarted = true;
    if (touchCount === 1) {
      longPressTimer = setTimeout(() => {
        if (touchCount === 1) {
          isLongPress = true;
          toggleSound();
        }
      }, LONG_PRESS_DURATION);
    }
    return;
  }

  if (touchCount === 1) {
    longPressTimer = setTimeout(() => {
      if (touchCount === 1) {
        isLongPress = true;
        toggleSound();
      }
    }, LONG_PRESS_DURATION);
  }
}, { passive: false });

document.body.addEventListener('touchend', (event) => {
  // Block app controls if MP3 generator modal is open
  if (isMP3GeneratorModalOpen()) {
    return;
  }
  
  event.preventDefault();
  Array.from(event.changedTouches || []).forEach(touch => {
    createRipple(touch.clientX, touch.clientY, false);
  });
  clearTimeout(longPressTimer);

  const remainingTouches = event.touches.length;
  if (remainingTouches > 0) {
    return;
  }

  const completedTouches = touchCount;

  if (isIntroScreen) {
    if (completedTouches === 3) {
      celebrateIntroScreen();
    } else if (introTapStarted && !isLongPress && completedTouches === 1) {
      startApp();
    }
    introTapStarted = false;
    isLongPress = false;
    touchCount = 0;
    return;
  }

  if (completedTouches === 2) {
    toggleTwoColorMode();
  } else if (completedTouches === 1 && !isLongPress) {
    changeColors();
  } else if (completedTouches === 3) {
    returnToIntro();
  }

  touchCount = 0;
}, { passive: false });

document.body.addEventListener('touchmove', (event) => {
  // Block app controls if MP3 generator modal is open
  if (isMP3GeneratorModalOpen()) {
    return;
  }
  
  const touch = event.touches && event.touches[0];
  if (touch) {
    updatePointerPosition(touch.clientX, touch.clientY);
  }
}, { passive: true });

['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(evt => {
  document.addEventListener(evt, repositionRipplesToLastPointer);
});

window.addEventListener('resize', repositionRipplesToLastPointer);

window.addEventListener('load', () => {
  checkMobile();
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.classList.add('title-fade-in');
  }
});
</script>
</body></html>
