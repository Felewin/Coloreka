<html><head>
<title>Coloreka!</title>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400..800&display=swap" rel="stylesheet">
<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
  
  body {
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    display: flex;
  }
  
  * {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
  }

  #leftColor, #rightColor {
    flex: 1;
    height: 100%;
    position: relative;
    overflow: hidden;
  }

  #rightColor {
    display: none;
  }

  .ripple {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: scale(0);
    opacity: 0;
    animation: rippleExpand 800ms ease-out forwards;
    z-index: 1100;
    mix-blend-mode: screen;
    will-change: transform, opacity;
  }

  @media (hover: none) and (pointer: coarse) {
    .ripple {
      mix-blend-mode: normal;
    }
  }

  .colorLayer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transition: opacity 0.5s ease;
  }

  .wipe-transition {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transition: transform 0.5s ease, opacity 0.5s ease;
    backface-visibility: hidden;
  }

  @keyframes zoomIn {
    from { transform: scale(0); }
    to { transform: scale(1); }
  }

  @keyframes rotateIn {
    from { transform: rotate(-180deg) scale(0); }
    to { transform: rotate(0) scale(1); }
  }

  #introScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, 
      #FFB3BA, #FFDFBA, #FFFFBA, #BAFFC9, #BAE1FF, #E0BBE4, #FFB3BA
    );
    background-size: 200% 100%;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    animation: moveGradient 10s linear infinite;
  }

  .baloo-2-intro-title {
    font-family: "Baloo 2", sans-serif;
    font-optical-sizing: auto;
    font-weight: 800;
    font-style: normal;
    font-size: 8vw;
    background: linear-gradient(
      to right,
      #FFB3BA, #E0BBE4, #BAE1FF, #BAFFC9, #FFFFBA, #FFDFBA, #FFB3BA
    );
    background-size: 200% auto;
    color: transparent;
    -webkit-background-clip: text;
    background-clip: text;
    opacity: 0;
    animation: rainbow 10s linear infinite;
    margin-bottom: 2vh;
  }

  .title-fade-in {
    animation: fadeIn 2s ease-in-out forwards, rainbow 10s linear infinite;
  }

  #introRules {
    font-family: "Baloo 2", sans-serif;
    font-size: 2vw;
    color: #333;
    text-align: left;
    background-color: rgba(255, 255, 255, 0.5);
    padding: 2vh;
    border-radius: 10px;
    max-width: 80%;
    overflow-y: auto;
    max-height: 60vh;
    animation: fadeIn 2s ease-in-out;
    position: relative;
  }

  #introRules h3 {
    margin-top: 0;
  }

  #introRules ul {
    list-style-type: none;
    padding-left: 0;
  }

  #introRules li {
    margin-bottom: 1vh;
  }

  .also-plays-text {
    position: absolute;
    top: 2vh;
    right: 2vh;
    font-size: 1.2vw;
    color: #333;
    font-weight: 600;
    opacity: 0.8;
  }

  @media (orientation: portrait) {
    .baloo-2-intro-title {
      font-size: 16vw;
    }
    #introRules {
      font-size: 4vw;
    }
    .also-plays-text {
      font-size: 4.8vw;
      top: auto;
      bottom: 2vh;
    }
  }

  @keyframes rainbow {
    0% {
      background-position: 0% center;
    }
    100% {
      background-position: -200% center;
    }
  }

  @keyframes moveGradient {
    0% {
      background-position: 0% 50%;
    }
    100% {
      background-position: -200% 50%;
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes rainbowMove {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
  }

  @keyframes rippleExpand {
    0% {
      opacity: 0;
      transform: scale(0.15);
      filter: blur(2px);
    }
    20% {
      opacity: 1;
      transform: scale(1.3);
      filter: blur(0);
    }
    100% {
      opacity: 0;
      transform: scale(9);
      filter: blur(2px);
    }
  }

  @media (hover: none) and (pointer: coarse) {
    @keyframes rippleExpand {
      0% {
        opacity: 0;
        transform: scale(0.15);
      }
      20% {
        opacity: 1;
        transform: scale(1.3);
      }
      100% {
        opacity: 0;
        transform: scale(9);
      }
    }
  }

  @keyframes titleJiggle {
    0% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.15) rotate(3deg); }
    50% { transform: scale(1.075) rotate(-1.5deg); }
    75% { transform: scale(1.12) rotate(1.5deg); }
    100% { transform: scale(1) rotate(0deg); }
  }

  @media (hover: none) and (pointer: coarse) {
    @keyframes titleJiggle {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.3) rotate(6deg); }
      50% { transform: scale(1.15) rotate(-3deg); }
      75% { transform: scale(1.24) rotate(3deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
  }

  .jiggle {
    animation: titleJiggle 300ms ease-in-out;
  }

  .rainbow-color {
    background: linear-gradient(
      to right,
      red,
      orange,
      yellow,
      green,
      blue,
      indigo,
      violet,
      red
    );
    background-size: 200% 100%;
    animation: rainbowMove 10s linear infinite;
  }
</style>
</head>
<body>
<div id="introScreen">
  <div class="baloo-2-intro-title">Coloreka!</div>
  <div id="introRules"></div>
</div>
<div id="leftColor">
  <div class="colorLayer"></div>
</div>
<div id="rightColor">
  <div class="colorLayer"></div>
</div>


<script>
const colors = ['red', 'green', 'blue', 'yellow', 'purple'];
const rippleColors = ['#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#E964FF', '#FFA1C9'];
let currentLeftColor, currentRightColor;
let soundOn = true;
let touchStartTime = 0;
let touchCount = 0;
let longPressTimer;
let isTwoColorMode = false;
const LONG_PRESS_DURATION = 700; // milliseconds
let touchStartY = 0;
let isMobile = false;
let lastInteractionTime = 0;
const INTERACTION_COOLDOWN = 50; // 50ms cooldown between interactions
let isIntroScreen = true;
let introTapStarted = false;
let lastModeSwitchTime = 0;
const MODE_SWITCH_COOLDOWN = 300; // 300ms cooldown for mode switching
let isShiftKeyDown = false;
let colorChangesSinceIntro = 0;
let lastPointerPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let lastPointerRatio = { x: 0.5, y: 0.5 };
let rippleFollowHandle = null;
let lastSwishSound = null;
const swishSounds = ['audio/Swish (1).mp3', 'audio/Swish (2).mp3', 'audio/Swish (3).mp3', 'audio/Swish (4).mp3'];
/* DISABLED: Cloud TTS functionality - disabled due to high latency
// Coloreka cloud TTS service endpoint - provides high-quality text-to-speech with expressive voices
// May be rate limited or unavailable, in which case the app falls back to device's built-in voice
const TTS_SERVICE_URL = 'https://steep-sound-5d19.hunterbobeck.workers.dev';
*/

// Tracks the currently playing audio from the cloud TTS service
// Used to stop playback if a new voice request comes in (either cloud or device voice)
// This ensures only one voice plays at a time and prevents overlapping audio
let currentAIAudio = null;

/* DISABLED: Cloud TTS functionality - disabled due to high latency
// Debug function to test Worker directly - call testWorker() in console
window.testWorker = async function() {
  console.log('Testing Worker...');
  try {
    const response = await fetch(TTS_SERVICE_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: 'test' }),
    });
    console.log('Status:', response.status);
    console.log('Headers:', Object.fromEntries(response.headers.entries()));
    if (response.status === 200) {
      const blob = await response.blob();
      console.log('Success! Audio blob size:', blob.size, 'bytes');
    } else {
      const text = await response.text();
      console.log('Response body:', text);
    }
  } catch (error) {
    console.error('Error:', error);
  }
};
*/

function playAudio(src, volume = 0.05) {
  const audio = new Audio(src);
  audio.volume = volume;
  audio.play().catch(err => {
    console.log(`Error playing sound: ${err.message}`);
  });
}

function setLayerColor(layer, color) {
  if (!layer) return;
  layer.classList.remove('rainbow-color');
  if (color === 'rainbow') {
    layer.classList.add('rainbow-color');
    layer.style.backgroundColor = '';
  } else {
    layer.style.backgroundColor = color;
  }
}

function getRandomColor(currentLeftColor, currentRightColor) {
  let newColor;
  do {
    // Only allow rainbow after 5 changes since intro
    if (colorChangesSinceIntro > 5 && Math.random() < 0.025) {
      newColor = 'rainbow';
    } else {
      newColor = colors[Math.floor(Math.random() * colors.length)];
    }
  } while (newColor === currentLeftColor || newColor === currentRightColor);
  return newColor;
}

function changeColors() {
  if (isIntroScreen) return;

  const currentTime = new Date().getTime();
  if (currentTime - lastInteractionTime < INTERACTION_COOLDOWN) {
    return;
  }
  lastInteractionTime = currentTime;

  const previousLeftColor = currentLeftColor;
  const previousRightColor = currentRightColor;
  
  currentLeftColor = getRandomColor(currentLeftColor, currentRightColor);
  currentRightColor = getRandomColor(currentLeftColor, currentRightColor);

  colorChangesSinceIntro++; // Increment counter

  applyTransition('leftColor', currentLeftColor);
  if (isTwoColorMode) {
    applyTransition('rightColor', currentRightColor);
  }

  // Play swish sound when advancing
  playSwishSound();

  // Gentle vibration when advancing
  vibrateGentle();

  if (soundOn) {
    if (isTwoColorMode) {
      speak(`${previousLeftColor} and ${previousRightColor}`, true); // Always use device voice in two color mode
    } else {
      speak(previousLeftColor);
    }
  }

  requestFullscreen();
}

function applyTransition(elementId, newColor) {
  const container = document.getElementById(elementId);
  const currentLayer = container.querySelector('.colorLayer');
  const newLayer = document.createElement('div');

  newLayer.className = 'wipe-transition';
  setLayerColor(newLayer, newColor);

  const effects = ['slide', 'zoom', 'rotate', 'curl', 'spin'];
  const effect = effects[Math.floor(Math.random() * effects.length)];
  
  switch(effect) {
    case 'slide':
      applySlideTransition(newLayer);
      break;
    case 'zoom':
      newLayer.style.transform = 'scale(0)';
      newLayer.style.opacity = '0';
      break;
    case 'rotate':
      newLayer.style.transform = 'rotate(-180deg) scale(0)';
      newLayer.style.opacity = '0';
      break;
    case 'curl':
      applyCurlTransition(newLayer);
      break;
    case 'spin':
      applySpinTransition(newLayer);
      break;
  }
  
  container.appendChild(newLayer);
  
  setTimeout(() => {
    switch(effect) {
      case 'slide':
        newLayer.style.transform = 'translate(0, 0)';
        break;
      case 'zoom':
        newLayer.style.transform = 'scale(1)';
        newLayer.style.opacity = '1';
        break;
      case 'rotate':
        newLayer.style.transform = 'rotate(0) scale(1)';
        newLayer.style.opacity = '1';
        break;
      case 'curl':
        newLayer.style.transform = 'perspective(1000px) rotateY(0deg)';
        newLayer.style.opacity = '1';
        break;
      case 'spin':
        newLayer.style.transform = 'rotate(0deg) scale(1)';
        newLayer.style.opacity = '1';
        break;
    }
  }, 50);
  
  setTimeout(() => {
    currentLayer.remove();
    newLayer.className = 'colorLayer';
    setLayerColor(newLayer, newColor);
  }, 550);
}

function applySpinTransition(newLayer) {
  newLayer.style.transformOrigin = 'center center';
  newLayer.style.transform = 'rotate(720deg) scale(0)';
  newLayer.style.opacity = '0';
}

function applyCurlTransition(newLayer) {
  newLayer.style.transformOrigin = 'bottom right';
  newLayer.style.transform = 'perspective(1000px) rotateY(-90deg)';
  newLayer.style.opacity = '0';
}

function applySlideTransition(newLayer) {
  const directions = ['Left', 'Right', 'Top', 'Bottom'];
  const direction = directions[Math.floor(Math.random() * directions.length)];
  
  switch(direction) {
    case 'Left':
      newLayer.style.transform = 'translateX(100%)';
      break;
    case 'Right':
      newLayer.style.transform = 'translateX(-100%)';
      break;
    case 'Top':
      newLayer.style.transform = 'translateY(100%)';
      break;
    case 'Bottom':
      newLayer.style.transform = 'translateY(-100%)';
      break;
  }
}

function applyFadeTransition(elementId, newColor) {
  const container = document.getElementById(elementId);
  const currentLayer = container.querySelector('.colorLayer');
  const newLayer = document.createElement('div');

  newLayer.className = 'colorLayer';
  setLayerColor(newLayer, newColor);
  
  newLayer.style.opacity = '0';
  container.appendChild(newLayer);
  
  setTimeout(() => {
    newLayer.style.opacity = '1';
    currentLayer.style.opacity = '0';
  }, 50);
  
  setTimeout(() => {
    currentLayer.remove();
  }, 550);
}

function startApp() {
  if (isIntroScreen) {
    isIntroScreen = false;
    document.getElementById('introScreen').style.display = 'none';
    currentLeftColor = getRandomColor();
    currentRightColor = getRandomColor(currentLeftColor);
    applyFadeTransition('leftColor', currentLeftColor);
    requestFullscreen();

    // Play gong sound when advancing from menu
    playGongSound();
  }
}

/**
 * Attempts to use the Coloreka cloud TTS service to generate and play speech audio.
 * 
 * DISABLED: Cloud TTS functionality has been disabled due to high latency.
 * This function now immediately returns false to use device voice instead.
 * 
 * @param {string} text - The text to convert to speech
 * @returns {Promise<boolean>} - Returns false (disabled)
 */
async function speakWithCloudTTS(text) {
  // DISABLED: Cloud TTS disabled due to high latency - always return false to use device voice
  return false;
  
  /* DISABLED CODE BELOW - Cloud TTS functionality disabled due to high latency
  // Voice interruption: Stop any currently playing cloud TTS audio
  // This ensures that if a new voice request comes in while audio is playing,
  // the old audio stops immediately so the new one can start
  if (currentAIAudio) {
    currentAIAudio.pause();
    currentAIAudio.currentTime = 0;
    currentAIAudio = null;
  }
  
  // Voice interruption: Cancel any currently playing device voice
  // This ensures cloud TTS audio can interrupt device voice playback
  speechSynthesis.cancel();
  
  // Track timing: Record when the request starts to measure response time
  const requestStartTime = Date.now();
  
  try {
    // Text transformation: Special handling for app title
    // When the app title is spoken, replace it with a more descriptive phrase
    // This provides better context for users learning the controls
    if (text === 'Coloreka!' || text === 'Coloreka') {
      text = 'Here are your controls';
    }
    
    // Tone enhancement: Add expressive vocal direction tags
    // The cloud TTS service supports tone modifiers in square brackets that affect
    // how the voice sounds - making it more cheerful, encouraging, or friendly
    // This creates a more engaging and supportive experience for users learning colors
    const toneTags = ['[cheerful]'];
    const randomTone = toneTags[Math.floor(Math.random() * toneTags.length)];
    
    // Content detection: Determine if the text is a color name
    // Color names get special treatment with prefixes, while other text (like instructions)
    // gets simpler formatting
    const colorNames = ['red', 'green', 'blue', 'yellow', 'purple', 'rainbow'];
    const isColor = colorNames.includes(text.toLowerCase());
    
    // Text enhancement: Add prefixes and exclamation points for more engaging speech
    // For colors: Randomly select from weighted prefix options to add variety
    //   - Empty prefix (just color name): ~27% chance - creates simple, direct statements
    //   - "It was": ~27% chance - common, natural phrasing
    //   - "That was": ~27% chance - common, natural phrasing  
    //   - "The color was": ~9% chance - more descriptive, used less frequently
    //   - "That one was": ~9% chance - more descriptive, used less frequently
    // For non-colors: Just add tone tag and exclamation point (no prefix)
    // All text gets an exclamation point for enthusiastic delivery
    let excitedText;
    if (isColor) {
      // TEMPORARILY DISABLED: Prefixes for color pronunciation
      // Weighted array: More instances of a prefix = higher probability of selection
      // This creates natural variation while favoring more common phrases
      // const prefixes = ['', '', '', 'It was ', 'It was ', 'It was ', 'That was ', 'That was ', 'That was ', 'The color was ', 'That one was '];
      // const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      
      // Spacing handling: If prefix is empty, don't add extra space after tone tag
      // This ensures proper formatting whether prefix is present or not
      // if (randomPrefix === '') {
      //   excitedText = randomTone + ' ' + text + '!';
      // } else {
      //   excitedText = randomTone + ' ' + randomPrefix + text + '!';
      // }
      
      // Temporary: No prefix, just tone tag and color name with exclamation
      excitedText = randomTone + ' ' + text + '..!.';
    } else {
      // For non-color text (like instructions), just add tone tag and exclamation point
      // No prefix is added to keep the message clear and direct
      excitedText = randomTone + ' ' + text + ' ..!.';
    }
    
    // Request audio from the Coloreka cloud TTS service
    // The service processes the enhanced text (with tone tags and prefixes) and returns audio data
    const response = await fetch(TTS_SERVICE_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text: excitedText,
        model: 'canopylabs/orpheus-v1-english',
        voice: 'hannah',
        response_format: 'wav'
      }),
    });

    // Success case: Cloud TTS service returned audio data (status 200)
    // Process the audio and play it with fade-out to avoid trailing sounds
    if (response.status === 200) {
      // Convert the response to an audio blob that can be played
      const audioBlob = await response.blob();
      
      // Create a temporary URL for the audio blob so it can be played
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      audio.volume = 0.25;
      
      // Store reference to the audio object
      // This allows us to stop playback if a new voice request comes in
      // The reference is cleared when audio finishes or is stopped
      currentAIAudio = audio;
      
      // Add error handler for audio playback
      audio.addEventListener('error', (e) => {
        currentAIAudio = null; // Clear reference on error
      });
      
      // Start playing the audio
      await audio.play();
      
      // Fade-out system: Smoothly reduce volume before the end to avoid trailing sounds
      // Some audio files may contain unwanted sounds (sighs, snorts, etc.) at the very end
      // By fading out slightly before the audio naturally ends, we cut off these artifacts
      // while maintaining a smooth, natural-sounding conclusion
      let isFadingOut = false;
      const originalVolume = audio.volume; // Store original volume to restore for next playback
      
      // Monitor audio playback progress to trigger fade-out at the right time
      audio.addEventListener('timeupdate', () => {
        // Trigger fade-out when we're 200ms away from the end of the audio
        // This gives us enough time to smoothly fade out before any trailing sounds
        if (!isFadingOut && audio.duration && audio.currentTime >= audio.duration - 0.2) {
          isFadingOut = true; // Mark that fade-out has started to prevent duplicate triggers
          
          // Fade-out parameters: Reduce volume to zero over 150ms
          // This creates a smooth transition that's fast enough to cut off artifacts
          // but slow enough to sound natural
          const fadeOutDuration = 0.15;
          const fadeOutStartTime = audio.currentTime;
          const fadeOutStartVolume = audio.volume;
          
          // Smooth fade-out: Update volume every 10ms for fluid transition
          // This creates a gradual volume reduction rather than an abrupt stop
          const fadeOutInterval = setInterval(() => {
            // Safety check: If audio was stopped externally, clean up and exit
            if (audio.paused || audio.ended) {
              clearInterval(fadeOutInterval);
              return;
            }
            
            // Calculate how far through the fade-out we are (0 to 1)
            const elapsed = audio.currentTime - fadeOutStartTime;
            if (elapsed >= fadeOutDuration) {
              // Fade-out complete: Stop playback and clean up resources
              audio.pause();
              audio.currentTime = 0;
              audio.volume = originalVolume; // Reset volume for next playback
              clearInterval(fadeOutInterval);
              currentAIAudio = null; // Clear reference so new audio can play
              URL.revokeObjectURL(audioUrl); // Free up memory from blob URL
            } else {
              // Gradually reduce volume: Linear fade from start volume to zero
              // Progress goes from 0 (start) to 1 (end), so (1 - progress) goes from 1 to 0
              const progress = elapsed / fadeOutDuration;
              audio.volume = fadeOutStartVolume * (1 - progress);
            }
          }, 10); // Update every 10ms for smooth fade (100 updates over 1 second)
        }
      });
      
      // Cleanup handler: If audio finishes naturally without fade-out triggering
      // This handles edge cases where audio might be shorter than expected
      // or if fade-out logic doesn't trigger for some reason
      audio.addEventListener('ended', () => {
        if (!isFadingOut) {
          audio.volume = originalVolume; // Reset volume for next playback
          currentAIAudio = null; // Clear reference so new audio can play
          URL.revokeObjectURL(audioUrl); // Free up memory from blob URL
        }
      }, { once: true }); // Only fire once to prevent duplicate cleanup
      
      // Return success: Audio is now playing
      return true;
    } else {
      // Non-success response: Cloud TTS service returned an error status
      // This could be due to rate limiting, service unavailability, or invalid request
      // Calculate and log response time
      const responseTime = Date.now() - requestStartTime;
      console.log(`Cloud TTS error after ${responseTime}ms`);
      await response.text(); // Consume response body
    }
  } catch (error) {
    // Network or request error: Failed to communicate with cloud TTS service
    // This could be due to network issues, CORS problems, or service downtime
    // Calculate and log response time
    const responseTime = Date.now() - requestStartTime;
    console.log(`Cloud TTS error after ${responseTime}ms`);
  }
  
  // Failure case: Return false to indicate cloud TTS did not succeed
  // The caller will use this to trigger fallback to device voice
  return false;
  */
}

/**
 * Main speech function: Converts text to speech using device voice.
 * 
 * Cloud TTS functionality has been disabled due to high latency.
 * All speech now uses the device's native text-to-speech engine.
 * 
 * @param {string} text - The text to convert to speech
 * @param {boolean} useDeviceVoiceOnly - Deprecated parameter (kept for compatibility, always uses device voice)
 */
async function speak(text, useDeviceVoiceOnly = false) {
  // Voice interruption: Stop any currently playing cloud TTS audio
  // This ensures that when a new speech request comes in, any old audio stops immediately
  // This prevents overlapping voices and ensures only the most recent request plays
  if (currentAIAudio) {
    currentAIAudio.pause();
    currentAIAudio.currentTime = 0;
    currentAIAudio = null;
  }
  
  // Voice interruption: Cancel any currently playing device voice
  // This ensures new requests can interrupt old ones
  speechSynthesis.cancel();
  
  // Use device voice directly
  // Cloud TTS disabled due to high latency - always use device voice for responsive experience
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.volume = 0.25;
  speechSynthesis.speak(utterance);
  
  /* DISABLED: Cloud TTS functionality - disabled due to high latency
  // Timeout fallback system: Track whether we've already started device voice
  // This flag prevents playing cloud audio if device voice already started due to timeout
  let fallbackUsed = false;
  
  // Responsive timeout: If cloud TTS doesn't respond within 1200ms, use device voice
  // This ensures speech always starts quickly, even if cloud service is slow or unavailable
  // The timeout fires independently - we don't wait the full time then check duration
  // Instead, as soon as 1200ms passes, device voice starts immediately
  const timeoutId = setTimeout(() => {
    // Timeout fired: Cloud TTS took too long, use device voice instead
    // Log that response exceeded maximum wait time
    console.log('Cloud TTS response exceeded maximum wait time (1200ms)');
    fallbackUsed = true; // Mark that we're using fallback
    
    // Safety: Stop cloud audio if it somehow started playing during the timeout
    // This prevents both voices playing simultaneously
    if (currentAIAudio) {
      currentAIAudio.pause();
      currentAIAudio.currentTime = 0;
      currentAIAudio = null;
    }
    
    // Start device voice immediately - user gets speech without further delay
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.volume = 0.25;
    speechSynthesis.speak(utterance);
  }, 1200); // 1200ms timeout - fast enough to feel instant, slow enough for cloud to respond if available
  
  // Attempt cloud TTS: Request audio from cloud service
  // This runs in parallel with the timeout - whichever completes first wins
  try {
    const cloudTTSSuccess = await speakWithCloudTTS(text);
    
    // Cloud TTS responded: Cancel the timeout since we got a response
    // If timeout already fired, this does nothing (which is fine)
    clearTimeout(timeoutId);
    
    // Check if timeout already triggered device voice
    // If so, ignore the cloud response to prevent interrupting device voice
    if (fallbackUsed) {
      // Timeout fired first: Device voice is already playing
      // Stop cloud audio if it started playing (shouldn't happen, but safety check)
      if (currentAIAudio) {
        currentAIAudio.pause();
        currentAIAudio.currentTime = 0;
        currentAIAudio = null;
      }
      // Exit: Don't play cloud audio, device voice is already playing
      // This ensures we don't interrupt the device voice that user is hearing
      return;
    }
    
    // Cloud TTS responded quickly (before timeout): Check if it succeeded
    // If cloud service failed (non-200 response), use device voice as backup
    // This handles cases where cloud responds quickly but with an error
    if (!cloudTTSSuccess) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.volume = 0.25;
      speechSynthesis.speak(utterance);
    }
    // If cloudTTSSuccess is true, cloud audio is already playing (handled in speakWithCloudTTS)
    
  } catch (error) {
    // Error during cloud TTS request: Cancel timeout and handle error
    clearTimeout(timeoutId);
    
    // If timeout already triggered device voice, ignore the error
    // Device voice is already playing, so we don't need to do anything
    if (fallbackUsed) {
      return;
    }
    
    // Error occurred and timeout didn't fire: Use device voice as fallback
    // This ensures user always gets speech, even if cloud service fails completely
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.volume = 0.25;
    speechSynthesis.speak(utterance);
  }
  */
}

function playSwishSound() {
  let availableSounds = swishSounds.filter(sound => sound !== lastSwishSound);
  const randomSound = availableSounds[Math.floor(Math.random() * availableSounds.length)];
  lastSwishSound = randomSound;

  playAudio(randomSound);
}

function playGongSound() {
  playAudio('audio/Gong.mp3');
}

function vibrateGentle() {
  if ('vibrate' in navigator) {
    navigator.vibrate(100); // 100ms vibration for better noticeability
  }
}

function toggleSound() {
  soundOn = !soundOn;
  speak(soundOn ? "Saying the colors" : "muted", true); // Always use device voice for status messages
}

function updatePointerPosition(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) return;
  const clampedX = Math.max(0, Math.min(window.innerWidth, x));
  const clampedY = Math.max(0, Math.min(window.innerHeight, y));
  lastPointerPosition = { x: clampedX, y: clampedY };
  lastPointerRatio = {
    x: window.innerWidth ? clampedX / window.innerWidth : 0,
    y: window.innerHeight ? clampedY / window.innerHeight : 0
  };
}

function getPointerPositionFromRatio() {
  return {
    x: window.innerWidth * lastPointerRatio.x,
    y: window.innerHeight * lastPointerRatio.y
  };
}

function positionRipplesAt(x, y) {
  document.querySelectorAll('.ripple').forEach(ripple => {
    const size = parseFloat(ripple.dataset.size) || ripple.offsetWidth || 0;
    if (!size) return;
    ripple.style.left = `${x - size / 2}px`;
    ripple.style.top = `${y - size / 2}px`;
  });
}

function jiggleTitle() {
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.classList.remove('title-fade-in');
    title.style.opacity = '1';
    title.classList.add('jiggle');
    setTimeout(() => title.classList.remove('jiggle'), 300);
  }
}

function celebrateIntroScreen() {
  jiggleTitle();
  if (soundOn) {
    speak("Coloreka!");
  }
}

function followRipplesToPointer() {
  positionRipplesAt(lastPointerPosition.x, lastPointerPosition.y);
  if (document.querySelector('.ripple')) {
    rippleFollowHandle = window.requestAnimationFrame(followRipplesToPointer);
  } else {
    rippleFollowHandle = null;
  }
}

function ensureRippleFollowerRunning() {
  if (rippleFollowHandle !== null) return;
  rippleFollowHandle = window.requestAnimationFrame(followRipplesToPointer);
}

function repositionRipplesToLastPointer() {
  const { x, y } = getPointerPositionFromRatio();
  lastPointerPosition = { x, y };
  positionRipplesAt(x, y);
}

function createRipple(x, y, followPointer = true) {
  if (typeof x !== 'number' || typeof y !== 'number') return;

  updatePointerPosition(x, y);

  const ripple = document.createElement('div');
  ripple.className = 'ripple';

  const size = 40 + Math.random() * 60;
  ripple.style.width = `${size}px`;
  ripple.style.height = `${size}px`;
  ripple.style.left = `${x - size / 2}px`;
  ripple.style.top = `${y - size / 2}px`;
  ripple.dataset.size = size;

  const color = 'white';
  ripple.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
  
  // Simpler shadow for mobile
  if (isMobile) {
    ripple.style.boxShadow = `0 0 15px ${color}`;
  } else {
    ripple.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
  }

  document.body.appendChild(ripple);
  if (followPointer && !isMobile) {
    ensureRippleFollowerRunning();
  }
  setTimeout(() => ripple.remove(), 850);
}

function toggleTwoColorMode() {
  const currentTime = new Date().getTime();
  if (currentTime - lastModeSwitchTime < MODE_SWITCH_COOLDOWN) {
    return;
  }
  lastModeSwitchTime = currentTime;

  isTwoColorMode = !isTwoColorMode;
  const rightColorElement = document.getElementById('rightColor');
    if (isTwoColorMode) {
      rightColorElement.style.display = 'block';
      if (!currentRightColor || currentRightColor === currentLeftColor) {
        currentRightColor = getRandomColor(currentLeftColor, currentLeftColor);
      }
      setLayerColor(rightColorElement.querySelector('.colorLayer'), currentRightColor);
    } else {
      rightColorElement.style.display = 'none';
    }
}

function returnToIntro() {
  isIntroScreen = true;
  colorChangesSinceIntro = 0; // Reset counter
  const introScreen = document.getElementById('introScreen');
  introScreen.style.display = 'flex';
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.style.opacity = '1';
    title.classList.remove('title-fade-in');
  }
  jiggleTitle();
  const introRules = document.getElementById('introRules');
  introRules.style.animation = 'none';
  introRules.offsetHeight; // Trigger reflow
  introRules.style.animation = null;
  document.getElementById('leftColor').innerHTML = '<div class="colorLayer"></div>';
  document.getElementById('rightColor').innerHTML = '<div class="colorLayer"></div>';
  document.getElementById('rightColor').style.display = 'none';
  isTwoColorMode = false;
  currentLeftColor = undefined;
  currentRightColor = undefined;
  if (soundOn) {
    speak("Coloreka!");
  }
}

function checkMobile() {
  isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  updateIntroRules();
}

function updateIntroRules() {
  const introRules = document.getElementById('introRules');
  const alsoPlaysText = isMobile ? '' : '<div class="also-plays-text">ü§≥ Also plays on mobile!</div>';
  introRules.innerHTML = `
    ${alsoPlaysText}
    <h3>${isMobile ? 'ü§≥ Mobile Controls!' : 'üñ•Ô∏è Desktop Controls!'}</h3>
    <ul>
      <li>‚ñ∂Ô∏è <strong>Advance</strong>! ${isMobile ? '<i>Tap</i>' : '<i>Click</i> on the screen, press <i>Enter</i>, or press <i>Spacebar</i>'}</li>
      <li>üîÑ <strong>Switch between single/two-color mode</strong>! ${isMobile ? '<i>Two-finger tap</i>' : 'Press the <i>Shift</i> key'}</li>
      <li>üîä <strong>Toggle saying the colors</strong>! ${isMobile ? '<i>Long press</i>' : "Press the <i>S</i> key"}</li>
      <li>üìú <strong>Show these instructions</strong>! ${isMobile ? '<i>Three-finger tap</i>' : 'Press <i>Escape</i>'}</li>
    </ul>
  `;
}

function requestFullscreen() {
  const element = document.documentElement;
  if (element.requestFullscreen) {
    element.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else if (element.mozRequestFullScreen) { // Firefox
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) { // Chrome, Safari and Opera
    element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) { // IE/Edge
    element.msRequestFullscreen();
  }
}

document.body.addEventListener('mousedown', (event) => {
  if (isMobile) {
    return;
  }

  createRipple(event.clientX, event.clientY);

  if (isIntroScreen) {
    startApp();
  } else {
    changeColors();
  }
});

document.addEventListener('keydown', (event) => {
  if (!isMobile) {
    switch (event.code) {
      case 'Enter':
      case 'Space':
        if (isIntroScreen) {
          startApp();
        } else {
          changeColors();
        }
        break;
      case 'KeyS':
        toggleSound(); // Allow sound toggling on intro screen
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        if (!isIntroScreen && !isShiftKeyDown) {
          isShiftKeyDown = true;
          toggleTwoColorMode();
        }
        break;
      case 'Escape':
        if (!isIntroScreen) {
          returnToIntro();
        } else {
          celebrateIntroScreen();
        }
        break;
    }
  }
});

document.addEventListener('mousemove', (event) => {
  if (isMobile) {
    return;
  }
  updatePointerPosition(event.clientX, event.clientY);
});

document.addEventListener('keyup', (event) => {
  if (!isMobile) {
    switch (event.code) {
      case 'ShiftLeft':
      case 'ShiftRight':
        isShiftKeyDown = false;
        break;
    }
  }
});

document.body.addEventListener('touchstart', (event) => {
  event.preventDefault();
  touchStartTime = new Date().getTime();
  touchCount = event.touches.length;
  isLongPress = false;
  touchStartY = event.touches[0].clientY;

  if (isIntroScreen) {
    introTapStarted = true;
    if (touchCount === 1) {
      longPressTimer = setTimeout(() => {
        if (touchCount === 1) {
          isLongPress = true;
          toggleSound();
        }
      }, LONG_PRESS_DURATION);
    }
    return;
  }

  if (touchCount === 1) {
    longPressTimer = setTimeout(() => {
      if (touchCount === 1) {
        isLongPress = true;
        toggleSound();
      }
    }, LONG_PRESS_DURATION);
  }
}, { passive: false });

document.body.addEventListener('touchend', (event) => {
  event.preventDefault();
  Array.from(event.changedTouches || []).forEach(touch => {
    createRipple(touch.clientX, touch.clientY, false);
  });
  clearTimeout(longPressTimer);

  const remainingTouches = event.touches.length;
  if (remainingTouches > 0) {
    return;
  }

  const completedTouches = touchCount;

  if (isIntroScreen) {
    if (completedTouches === 3) {
      celebrateIntroScreen();
    } else if (introTapStarted && !isLongPress && completedTouches === 1) {
      startApp();
    }
    introTapStarted = false;
    isLongPress = false;
    touchCount = 0;
    return;
  }

  if (completedTouches === 2) {
    toggleTwoColorMode();
  } else if (completedTouches === 1 && !isLongPress) {
    changeColors();
  } else if (completedTouches === 3) {
    returnToIntro();
  }

  touchCount = 0;
}, { passive: false });

document.body.addEventListener('touchmove', (event) => {
  const touch = event.touches && event.touches[0];
  if (touch) {
    updatePointerPosition(touch.clientX, touch.clientY);
  }
}, { passive: true });

['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(evt => {
  document.addEventListener(evt, repositionRipplesToLastPointer);
});

window.addEventListener('resize', repositionRipplesToLastPointer);

window.addEventListener('load', () => {
  checkMobile();
  const title = document.querySelector('.baloo-2-intro-title');
  if (title) {
    title.classList.add('title-fade-in');
  }
});
</script>
</body></html>
